package uk.ac.cam.amw223.raumschach;

import org.joml.Vector3i;

import java.util.ArrayList;
import java.util.List;

public class board {

  private static final int BOARD_SIZE = 5;
  private static final int SPACING = 2;

  public boolean dirty;

  private piece[][][] grid = new piece[BOARD_SIZE][BOARD_SIZE][BOARD_SIZE];

  private float[] vertexData;
  private float[] normalData;
  private float[] textureData;
  private int[] indexData;

  private boolean whiteHasKing = true;
  private boolean blackHasKing = true;

  private static float[] whiteTextureData = new float[]{
          0.1f, 0.1f,
          0.4f, 0.1f,
          0.4f, 0.4f
  };
  private static float[] blackTextureData = new float[]{
          0.6f, 0.1f,
          0.9f, 0.1f,
          0.9f, 0.4f
  };

  public board() {

    /*for (int i = 0; i < 20; i++) {
      boolean isWhite = i < 10;
      int x = (i / 5) + (isWhite? 0 : 1);
      int y = isWhite? 1 : 3;
      int z = i % 5;
      grid[x][y][z] = new pawn(isWhite);
    }*/

    // this one doesn't use as many magic numbers
    for (int i = 0; i < BOARD_SIZE * 4; i++) {
      boolean isWhite = i < BOARD_SIZE * 2;
      int x = (i / BOARD_SIZE) + (isWhite? 0 : BOARD_SIZE - 4);
      int y = isWhite? 1 : BOARD_SIZE - 2;
      int z = i % BOARD_SIZE;
      grid[x][y][z] = new pawn(isWhite);
    }

    for (int i = 0; i < 4; i++) {
      boolean isWhite = i < 2;
      int x = isWhite? 0 : 4;
      int z = (i % 2) * 4; // 0 or 4
      // x and y are the same number, this is not erroneous
      grid[x][x][z] = new rook(isWhite);
    }

    for (int i = 0; i < 4; i++) {
      boolean isWhite = i < 2;
      int x = isWhite? 0 : 4;
      int z = 1 + (i % 2) * 2; // 1 or 3
      // x and y are the same number, this is not erroneous
      grid[x][x][z] = new knight(isWhite);
    }

    for (int i = 0; i < 4; i++) {
      boolean isWhite = i < 2;
      int x = isWhite? 1 : 3;
      int y = isWhite? 0 : 4;
      int z = (i % 2) * 3; // 0 or 3
      grid[x][y][z] = new bishop(isWhite);
    }

    for (int i = 0; i < 4; i++) {
      boolean isWhite = i < 2;
      int x = isWhite? 1 : 3;
      int y = isWhite? 0 : 4;
      int z = 1 + (i % 2) * 3; // 1 or 4
      grid[x][y][z] = new dos(isWhite);
    }

    grid[0][0][2] = new king(true);
    grid[4][4][2] = new king(false);

    grid[1][0][2] = new queen(true);
    grid[3][4][2] = new queen(false);

    dirty = true;
  }

  public synchronized void generateModel() {

    // cannot pre-generate index buffer but can pre-generate model data.
    // these can be static in the piece classes, generated once at start of program,
    // null check in constructor for piece meaning the buffer is generated just once

    // no two vertices will ever share a location (lol not true) but will always share normals and indices
    // maybe this means the index buffer can be pre-generated?
    // index buffer could be generated by board to save on space (some pieces will share normals, e.g. rooks and pawns)

    // loop over the board
    //   if piece is not null
    //     add vertex, UV (generated here based on colour) and normal data to buffer
    //     adding piece position to vertices
    //   if a piece is selected now would be a good time to add valid move boxes
    //   check if this position is a valid move,
    //   if so we need to add it to the model data buffers
    // generate index buffers using alg in modelLoader

    // if the board hasn't changed, no need to regenerate the graphics data
    if (dirty) {

      List<Float> vertexBuffers = new ArrayList<>();
      List<Float> textureBuffers = new ArrayList<>();
      List<Float> normalBuffers = new ArrayList<>();
      List<Integer> indexBuffers = new ArrayList<>();

      int indexOffset = 0;

      for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
          for (int k = 0; k < BOARD_SIZE; k++) {
            if (grid[i][j][k] != null) {
              int count = 0;
              int offset = 0;
              for (float f : grid[i][j][k].getGameObject().getVertexBuffer()) {
                switch (count) {
                  case 0:
                    offset = j * SPACING;
                    break;
                  case 1:
                    offset = i * SPACING;
                    break;
                  case 2:
                    offset = k * SPACING;
                    break;
                }
                vertexBuffers.add(f + offset);
                count = (count + 1) % 3;
              }
              for (float f : grid[i][j][k].getGameObject().getNormalBuffer()) {
                normalBuffers.add(f);
              }
              count = 0;
              for (float f : grid[i][j][k].getGameObject().getUVBuffer()) {
                count = (count + 1) % 6;
                if (grid[i][j][k].isWhite()) {
                  textureBuffers.add(whiteTextureData[count]);
                } else {
                  textureBuffers.add(blackTextureData[2 * count]);
                }
              }
              for (int index : grid[i][j][k].getGameObject().getIndexBuffer()) {
                indexBuffers.add(index + indexOffset);
              }
              indexOffset = vertexBuffers.size() / 3;
            }
          }
        }
      }

      vertexData = new float[vertexBuffers.size()];
      for (int i = 0; i < vertexData.length; i++) {
         vertexData[i] = vertexBuffers.get(i);
      }

      normalData = new float[normalBuffers.size()];
      for (int i = 0; i < normalData.length; i++) {
        normalData[i] = normalBuffers.get(i);
      }

      textureData = new float[textureBuffers.size()];
      for (int i = 0; i < textureData.length; i++) {
        textureData[i] = textureBuffers.get(i);
      }

      indexData = new int[indexBuffers.size()];
      for (int i = 0; i < indexData.length; i++) {
        indexData[i] = indexBuffers.get(i);
      }

      dirty = false;
    }
  }

  public float[] getVertexData() {
    return vertexData;
  }

  public float[] getNormalData() {
    return normalData;
  }

  public float[] getTextureData() {
    return textureData;
  }

  public int[] getIndexData() {
    return indexData;
  }

  public synchronized void linkBoardToPieces() {
    for (int i = 0; i < BOARD_SIZE; i++) {
      for (int j = 0; j < BOARD_SIZE; j++) {
        for (int k = 0; k < BOARD_SIZE; k++) {
          if (grid[i][j][k] != null)
            grid[i][j][k].linkBoard(this);
        }
      }
    }
  }

  public synchronized piece getPiece(position pos) {
    return grid[pos.getI()][pos.getJ()][pos.getK()];
  }

  public boolean hasKing(boolean color) {
    if (color)
      return whiteHasKing;
    else
      return blackHasKing;
  }

  public synchronized void makeMove(position start, position end, boolean turn) throws InvalidMoveException {

    // piece to move exists
    if (getPiece(start) == null || getPiece(start).isWhite() != turn)
      throw new InvalidMoveException(false, true);
    // piece to move and to take are not the same colour
    if (getPiece(end) != null && getPiece(start).isWhite() == getPiece(end).isWhite())
      throw new InvalidMoveException(true, false);
    // piece to move can move in such a way
    if (!getPiece(start).verifyMove(start, end))
      throw new InvalidMoveException(true, false);

    if (!getPiece(start).getName().equals("knight")) {
      Vector3i d = new Vector3i();
      Vector3i loop = new Vector3i();
      end.asVector().sub(start.asVector(), d);
      int max = Math.max(Math.abs(d.x),
                Math.max(Math.abs(d.y),
                         Math.abs(d.z)));
      d.div(max);
      for (int i = 1; i <= max; i++) {
        d.mul(i, loop);
        if (getPiece(position.fromVector(start.asVector().add(loop))) != null) {
          throw new InvalidMoveException(true, false);
        }
      }
    }

    // if taking the king then update hasKing
    if (grid[end.getI()][end.getJ()][end.getK()] != null &&
            grid[end.getI()][end.getJ()][end.getK()].getName().equals("king"))
      if (grid[end.getI()][end.getJ()][end.getK()].isWhite())
        whiteHasKing = false;
      else
        blackHasKing = false;
    // move piece (overwriting the piece to take if relevant)
    grid[end.getI()][end.getJ()][end.getK()] = getPiece(start);
    grid[start.getI()][start.getJ()][start.getK()] = null;
    dirty = true;
  }

  public synchronized void initialiseGraphics() {
    for (int i = 0; i < BOARD_SIZE; i++) {
      for (int j = 0; j < BOARD_SIZE; j++) {
        for (int k = 0; k < BOARD_SIZE; k++) {
          if (grid[i][j][k] != null)
            grid[i][j][k].initialiseGraphics();
        }
      }
    }
  }

  public static int boardSize() {
    return BOARD_SIZE;
  }

  @Override
  public synchronized String toString() {
    String result = "";
    for (int i = 0; i < BOARD_SIZE; i++) {
      result += "Level " + (char)((int)'A' + i) + "\n\n";
      result += "  a    b    c    d    e  \n";
      for (int j = 0; j < BOARD_SIZE; j++) {
        result += "|----|----|----|----|----|\n";
        for (int k = 0; k < BOARD_SIZE; k++) {
          result += "| ";
          if (grid[i][j][k] == null)
            result += "  ";
          else
            result += grid[i][j][k];
          result += " ";
        }
        result += "| " + (j + 1) + "\n";
      }
      result += "|----|----|----|----|----|\n\n";
    }
    return result;
  }
}
